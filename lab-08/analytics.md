# Анализ корректности жадных алгоритмов

## 1. Задача о выборе заявок (Interval Scheduling)

### Алгоритм
Жадная стратегия: сортировка интервалов по времени окончания и выбор следующего рано заканчивающегося непересекающегося интервала.

### Доказательство корректности

**Теорема:** Жадный алгоритм находит оптимальное решение задачи о выборе заявок.

**Доказательство:**

Пусть `G` - решение, найденное жадным алгоритмом, а `O` - оптимальное решение.

1. **Базовый случай:** Если `G` содержит все интервалы, которые может выбрать жадный алгоритм, то `|G| = |O|`, так как жадный алгоритм выбирает максимально возможное количество.

2. **Индуктивный шаг:** Предположим, что первые `k` интервалов в `G` и `O` совпадают. Рассмотрим `(k+1)`-й интервал:
   - Жадный алгоритм выбирает интервал `g` с минимальным временем окончания среди всех непересекающихся интервалов.
   - Если `O` также содержит `g`, то переходим к следующему интервалу.
   - Если `O` содержит другой интервал `o` вместо `g`, то:
     - `g` заканчивается не позже `o` (по определению жадного выбора)
     - Можно заменить `o` на `g` в `O`, получив решение с тем же количеством интервалов
     - Это означает, что `G` не хуже `O`

3. **Заключение:** Поскольку `O` оптимально, а `G` не хуже `O`, то `G` также оптимально.

**Временная сложность:** O(n log n) - доминирует сортировка интервалов.

---

## 2. Непрерывный рюкзак (Fractional Knapsack)

### Алгоритм
Жадная стратегия: сортировка предметов по убыванию удельной стоимости (цена/вес) и взятие максимально возможного количества лучших предметов.

### Доказательство корректности

**Теорема:** Жадный алгоритм находит оптимальное решение задачи о непрерывном рюкзаке.

**Доказательство:**

Пусть `G` - решение жадного алгоритма, `O` - оптимальное решение.

1. **Предположение от противного:** Пусть `O` имеет большую стоимость, чем `G`.

2. **Анализ:** Рассмотрим первый предмет, который обрабатывается по-разному:
   - Жадный алгоритм берет предмет `i` с максимальной удельной стоимостью `v_i/w_i`
   - Если в `O` предмет `i` взят не полностью, а предмет `j` с меньшей удельной стоимостью взят, то:
     - Можно заменить часть предмета `j` на часть предмета `i` того же веса
     - Это увеличит стоимость (так как `v_i/w_i > v_j/w_j`)
     - Получили противоречие с оптимальностью `O`

3. **Заключение:** Жадный алгоритм всегда выбирает предметы в порядке убывания удельной стоимости, что и является оптимальной стратегией для непрерывного рюкзака.

**Временная сложность:** O(n log n) - доминирует сортировка предметов.

**Важное замечание:** Для дискретной версии задачи (0-1 рюкзак) жадный алгоритм может давать неоптимальное решение. Например:
- Предметы: (вес=10, стоимость=60), (вес=20, стоимость=100), (вес=30, стоимость=120)
- Вместимость: 50
- Жадный (непрерывный): берет полностью первые два предмета → стоимость = 160
- Точный (0-1): берет первый и третий → стоимость = 180

---

## 3. Алгоритм Хаффмана (Huffman Coding)

### Алгоритм
Построение оптимального префиксного кода путем многократного объединения двух символов с наименьшими частотами.

### Доказательство корректности

**Теорема:** Алгоритм Хаффмана строит оптимальный префиксный код.

**Доказательство (основные идеи):**

1. **Лемма о двух наименее частых символах:** В оптимальном коде два наименее частых символа имеют коды одинаковой длины и отличаются только последним битом.

2. **Оптимальная подструктура:** Если удалить два наименее частых символа и заменить их одним объединенным символом, то оптимальный код для новой задачи можно получить из оптимального кода исходной задачи.

3. **Жадный выбор:** На каждом шаге алгоритм объединяет два символа с наименьшими частотами, что соответствует лемме.

4. **Индукция:** 
   - Базовый случай: для двух символов алгоритм строит оптимальный код (0 и 1)
   - Индуктивный шаг: если алгоритм строит оптимальный код для `n-1` символов, то он строит оптимальный код для `n` символов

**Временная сложность:** O(n log n), где n - количество уникальных символов. Используется приоритетная очередь (куча).

**Оптимальность:** Алгоритм Хаффмана гарантирует минимальную среднюю длину кода среди всех префиксных кодов.

---

## 4. Задача о минимальном количестве монет

### Алгоритм
Жадная стратегия: на каждом шаге выбирать наибольшую монету, которая не превышает оставшуюся сумму.

### Анализ корректности

**Важно:** Жадный алгоритм работает корректно **не для всех** систем монет!

**Условие корректности (каноническая система монет):**

Система монет называется канонической, если для любого номинала `c_i` и любой суммы `S`, оптимальное решение для `S` содержит не более одной монеты номинала `c_i`, если `c_i > S/2`.

**Примеры:**
- ✅ **Каноническая система:** {1, 5, 10, 25, 50, 100} - жадный алгоритм работает
- ❌ **Некanonическая система:** {1, 3, 4} - жадный алгоритм может дать неоптимальное решение
  - Для суммы 6: жадный → 4 + 1 + 1 = 3 монеты
  - Оптимально: 3 + 3 = 2 монеты

**Доказательство для канонических систем:**

Для стандартной системы монет (1, 5, 10, 25, 50, 100) можно доказать, что:
1. Каждый номинал делится на предыдущий без остатка (кроме 1)
2. Оптимальное решение всегда содержит максимально возможное количество наибольших монет

**Временная сложность:** O(n), где n - количество различных номиналов.

---

## 5. Алгоритм Прима (Минимальное остовное дерево)

### Алгоритм
Начинаем с произвольной вершины и на каждом шаге добавляем ребро минимального веса, соединяющее уже включенную вершину с ещё не включенной.

### Доказательство корректности

**Теорема:** Алгоритм Прима находит минимальное остовное дерево.

**Доказательство:**

1. **Инвариант:** На каждом шаге множество включенных вершин образует поддерево некоторого MST.

2. **Базовый случай:** Начальная вершина образует тривиальное поддерево.

3. **Индуктивный шаг:** 
   - Пусть `T` - текущее поддерево MST
   - Алгоритм добавляет ребро `(u, v)` минимального веса, где `u ∈ T`, `v ∉ T`
   - По свойству разреза: если `(u, v)` - ребро минимального веса, пересекающее разрез `(T, V\T)`, то оно принадлежит некоторому MST
   - Следовательно, `T ∪ {(u, v)}` также является поддеревом MST

4. **Заключение:** Когда все вершины включены, полученное дерево является MST.

**Временная сложность:** 
- С бинарной кучей: O(E log V)
- С фибоначчиевой кучей: O(E + V log V)

---

## Сравнительный анализ эффективности

### Жадный подход vs Полный перебор

#### 1. Задача о выборе заявок
- **Жадный алгоритм:** O(n log n) - очень эффективен
- **Полный перебор:** O(2^n) - экспоненциальная сложность
- **Вывод:** Жадный алгоритм значительно быстрее и находит оптимальное решение

#### 2. Рюкзак
- **Жадный (непрерывный):** O(n log n) - оптимален для непрерывной версии
- **Точный (0-1):** O(2^n) полный перебор, O(nW) динамическое программирование
- **Вывод:** 
  - Для непрерывного рюкзака жадный алгоритм оптимален и быстр
  - Для 0-1 рюкзака жадный алгоритм может давать неоптимальное решение, но работает быстрее

#### 3. Алгоритм Хаффмана
- **Жадный алгоритм:** O(n log n) - оптимален
- **Альтернативы:** Другие методы построения префиксных кодов (например, Шеннона-Фано) могут быть быстрее, но не гарантируют оптимальность
- **Вывод:** Алгоритм Хаффмана является стандартом для оптимального сжатия

---

## Ограничения жадного подхода

### 1. Не все задачи решаются жадным подходом
- **0-1 рюкзак:** Жадный алгоритм не гарантирует оптимальность
- **Задача коммивояжёра:** Жадный алгоритм (ближайший сосед) дает приближенное решение
- **Некоторые задачи планирования:** Требуют динамического программирования

### 2. Зависимость от структуры задачи
- Жадный подход работает, когда задача обладает свойством **жадного выбора** и **оптимальной подструктуры**
- Необходимо доказательство корректности для каждой конкретной задачи

### 3. Локальная оптимизация
- Жадный алгоритм делает локально оптимальный выбор на каждом шаге
- Это не всегда приводит к глобально оптимальному решению

---

## Выводы

1. **Жадные алгоритмы эффективны** для задач с определенной структурой (жадный выбор + оптимальная подструктура)

2. **Временная сложность** жадных алгоритмов обычно лучше, чем у точных методов (O(n log n) vs O(2^n))

3. **Корректность** жадного подхода необходимо доказывать для каждой задачи отдельно

4. **Применимость** ограничена задачами, где локально оптимальный выбор ведет к глобально оптимальному решению

5. **Практическая ценность:** Жадные алгоритмы широко используются в реальных приложениях благодаря своей эффективности и простоте реализации

---

## Экспериментальные результаты

### Алгоритм Хаффмана

Результаты замеров производительности показывают:
- Время работы растет линейно с размером входных данных (O(n log n) на практике близко к линейному)
- Коэффициент сжатия зависит от распределения частот символов
- Алгоритм эффективен даже для больших объемов данных

### Сравнение рюкзака

- Жадный алгоритм для непрерывного рюкзака работает значительно быстрее точного алгоритма для 0-1 рюкзака
- Для непрерывной версии жадный алгоритм дает оптимальное решение
- Для дискретной версии может быть разница в стоимости, но жадный алгоритм работает быстрее

