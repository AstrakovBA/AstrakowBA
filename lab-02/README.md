# Анализ производительности структур данных

Проект для демонстрации принципов работы связного списка (LinkedList) и сравнительного анализа производительности различных структур данных.

## Описание

Проект реализует:
- Класс LinkedList с основными операциями
- Анализ производительности list vs LinkedList vs deque
- Решение задач с использованием различных структур данных
- Визуализацию результатов производительности

## Структура проекта

```
├── src/
│   ├── main.py                    # Главный файл для запуска
│   └── modules/
│       ├── linked_list.py         # Реализация LinkedList, Stack, Queue
│       ├── performance_analysis.py # Анализ производительности
│       └── task_solutions.py      # Решение задач
├── docs/                      # Графики и документация
├── requirements.txt           # Зависимости
└── README.md                  # Документация
```

## Установка зависимостей

```bash
pip install -r requirements.txt
```

## Запуск

### Полная демонстрация (запускается автоматически)
```bash
python src/main.py
```

### Отдельные компоненты
```bash
# Только LinkedList
python src/modules/linked_list.py

# Только анализ производительности
python src/modules/performance_analysis.py

# Только решение задач
python src/modules/task_solutions.py
```

## Реализованные структуры данных

### LinkedList
- `insert_at_start(data)` - O(1) - вставка в начало
- `insert_at_end(data)` - O(1) - вставка в конец (с хвостом)
- `delete_from_start()` - O(1) - удаление из начала
- `traversal()` - O(n) - обход всех элементов
- `search(data)` - O(n) - поиск элемента

### Stack (на основе LinkedList)
- `push(data)` - O(1) - добавление в стек
- `pop()` - O(1) - извлечение из стека
- `peek()` - O(1) - просмотр верхнего элемента

### Queue (на основе LinkedList)
- `enqueue(data)` - O(1) - добавление в очередь
- `dequeue()` - O(1) - извлечение из очереди
- `front()` - O(1) - просмотр первого элемента
- `rear()` - O(1) - просмотр последнего элемента

## Анализ производительности

Проект сравнивает:
1. **list vs LinkedList** для операций вставки в начало
2. **list vs deque** для операций удаления из начала
3. **list vs LinkedList** для операций добавления в конец
4. **list vs LinkedList** для операций обхода

### Результаты
- LinkedList превосходит list для операций вставки/удаления в начало
- deque превосходит list для операций удаления из начала
- Все операции измеряются с помощью timeit

## Решенные задачи

### 1. Проверка сбалансированности скобок
Использует стек для проверки правильности расстановки скобок `()`, `[]`, `{}`.

### 2. Симуляция очереди печати
Демонстрирует работу очереди FIFO с использованием deque для обработки документов.

### 3. Проверка палиндромов
Сравнивает различные методы проверки палиндромов:
- deque (O(n))
- list (O(n²))
- string (O(n))

## Визуализация

Проект создает графики производительности в **отдельных окнах**, показывающие:
- Зависимость времени выполнения от количества элементов
- Сравнение различных структур данных
- Логарифмический масштаб для лучшей видимости различий

### Создаваемые графики (сохраняются в папку docs/):
1. **docs/insert_at_start.png** - Сравнение вставки в начало (list vs LinkedList)
2. **docs/pop_from_start.png** - Сравнение удаления из начала (list vs deque)
3. **docs/insert_at_end.png** - Сравнение добавления в конец (list vs LinkedList)
4. **docs/traversal.png** - Сравнение обхода элементов (list vs LinkedList)
5. **docs/performance_analysis.png** - Сводный график со всеми сравнениями

Каждый график открывается в отдельном окне для удобного просмотра и анализа.

## Ключевые выводы

1. **LinkedList** оптимален для частых операций вставки/удаления в начало
2. **deque** превосходит list для операций удаления из начала
3. **Стек** идеален для задач с LIFO логикой (проверка скобок)
4. **Очередь** эффективна для FIFO операций
5. **deque** оптимален для проверки палиндромов

## Требования

- Python 3.7+
- matplotlib (для графиков)
- numpy (для численных операций)

## Автор

Проект создан для демонстрации принципов работы структур данных и анализа их производительности.
